#pragma once
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <functional>
namespace Render
{

auto SquareBuffer() ->	std::function<void(void)>;

enum class DrawMethod : GLenum {
  Static = GL_STATIC_DRAW, Dynamic = GL_DYNAMIC_DRAW };
  
struct Attribute
{
  std::size_t offset_;
  std::size_t size_;
  std::size_t dim_;
  DrawMethod method_;
};
  
class Buffer
{
private:
  unsigned int vao_, vbo_, ebo_;
  std::vector<Attribute> attributes_;
  std::size_t size_;

  template <class C>
  void AddAttribute(const C& container, DrawMethod method = DrawMethod::Static)
  {
    using vector = C::value_type;
    auto dim = sizeof(vector)/sizeof(float);		
    auto size = std::size(container) * sizeof(vector);
    size_ = std::size(container);
    auto offset = std::size(attributes_) ? attributes_.back().offset_ + attributes_.back().size_  : 0;
    
    glBufferSubData(GL_ARRAY_BUFFER, offset,
		    size,
		    container.data(), method); 
    glEnableVertexAttribArray(std::size(attributes_));
    glVertexAttribPointer(std::size(attributes_), dim, GL_FLOAT, GL_FALSE,
			  sizeof(vector), (void*)(offset));
    attributes_.emplace_back(offset, size, dim, method);
  } 

  template <class C>
  void Update(const C& container, std::size_t index)
  {
    auto size = attributes_[index].size_; 
    auto offset =  attributes_[index].offset_;
    auto method =  attributes_[index].method_;

    glBufferSubData(GL_ARRAY_BUFFER, 
		    size,
		    container.data(), method);
  }

public:
  template <class ...C>
  Buffer(const C& ...containers, DrawMethod method = DrawMethod::Static)
  {	
    glGenVertexArrays(1, &vao_);
    glGenBuffers(1, &vbo_);
    glBindVertexArray(vao_);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_);
    (..., AddAttribute(containers, method));
    glBindVertexArray(0);
  }

  std::size_t Size() const { return size_; }
  unsigned int Vao() const { return vao_; }
};

  auto PointsBuffer(const Buffer&) -> std::function<void(void)>;

}
